import "../sha/1024bitPacked.code" as sha256

// Note = (_owner, _value, _type, _senderViewingKey, _salt, _isSmart)

// o1 = makerNote
// o2 = takerNotetoMaker
// n0 = newNote0 from makerNote
// n1 = newNote1 from makerNote
// n2 = newNote2 from takerNotetoMaker
// n3 = newNote3 from takerNotetoMaker

def main(field o0h0, field o0h1, field o0Type, private field o0pk0, private field o0pk1, private field o0Val, private field o0vk0, private field o0vk1, private field o0Salt, private field o0IsSmart, field o1h0, field o1h1, field o1Type, private field o1pk0, private field o1pk1, private field o1Val, private field o1vk0, private field o1vk1, private field o1Salt, private field o1IsSmart, field n0h0, field n0h1, field n0Type, field n0rpk0, private field n0rpk1, private field n0Val, private field n0vk0, private field n0vk1, private field n0Salt, private field n0IsSmart, field n1h0, field n1h1, field n1Type, private field n1rpk0, private field n1rpk1, private field n1Val, private field n1vk0, private field n1vk1, private field n1Salt, private field n1IsSmart, field n2h0, field n2h1, field n2Type, private field n2rpk0, private field n2rpk1, private field n2Val, private field n2vk0, private field n2vk1, private field n2Salt, private field n2IsSmart, field n3h0, field n3h1, field n3Type, private field n3rpk0, private field n3rpk1, private field n3Val, private field n3vk0, private field n3vk1, private field n3Salt, private field n3IsSmart, field pnh0, field pnh1, field price) -> (field):  
  field check = o0Val - o1Val/price
  
  // o1Val/price should be positive integer

  field bit = if check <= o0Val then 1 else 0 fi
  // if check <= o0Val - o1Val/price, then o0Val >= o1Val/price
  // if bit == 1, then makerNote.value >= takerNoteToMaker.value/price
  // if bit == 0, then makerNote.value < takerNoteToMaker.value/price

  field n0ValT = if bit == 1 then o1Val/price else o0Val fi
  field n1ValT = if bit == 1 then o0Val - o1Val/price else 0 fi
  field n2ValT = if bit == 1 then o1Val else o0Val*price fi
  field n3ValT = if bit == 1 then 0 else o1Val - o0Val*price fi

  n0Val == n0ValT
  n1Val == n1ValT
  n2Val == n2ValT
  n3Val == n3ValT

  field n1rpk0T = if bit == 1 then o0pk0 else pnh0 fi
  field n1rpk1T = if bit == 1 then o0pk1 else pnh1 fi
  field n3rpk0T = if bit == 1 then o0pk0 else pnh0 fi
  field n3rpk1T = if bit == 1 then o0pk1 else pnh1 fi

  n1rpk0 == n1rpk0T
  n1rpk1 == n1rpk1T
  n3rpk0 == n3rpk0T
  n3rpk1 == n3rpk1T

  // get public key corresponding to private key
  // circuit for below hasn't been implemented as yet, so directly using the private key for PoC

  // check o0
  h = sha256([o0pk0, o0pk1, o0Val, o0Type, o0vk0, o0vk1, o0Salt, o0IsSmart])
  o0h0 == h[0]
  o0h1 == h[1]

  // check o1
  h = sha256([o1pk0, o1pk1, o1Val, o1Type, o1vk0, o1vk1, o1Salt, o1IsSmart])
  o1h0 == h[0]
  o1h1 == h[1]

  // check n0
  h = sha256([n0rpk0, n0rpk1, n0Val, n0Type, n0vk0, n0vk1, n0Salt, n0IsSmart])
  n0h0 == h[0]
  n0h1 == h[1]

  // check n1
  h = sha256([n1rpk0, n1rpk1, n1Val, n1Type, n1vk0, n1vk1, n1Salt, n1IsSmart])
  n1h0 == h[0]
  n1h1 == h[1]

  // check n2
  h = sha256([n2rpk0, n2rpk1, n2Val, n2Type, n2vk0, n2vk1, n2Salt, n2IsSmart])
  n2h0 == h[0]
  n2h1 == h[1]

  // check n3
  h = sha256([n3rpk0, n3rpk1, n3Val, n3Type, n3vk0, n3vk1, n3Salt, n3IsSmart])
  n3h0 == h[0]
  n3h1 == h[1]

  return 1